---
title: 《消息队列高手课》学习笔记
categories:
  - 笔记
tags:
  - 架构
  - 中间件
  - 消息队列
date: 2022-05-11 20:59:25
---

# 《消息队列高手课》学习笔记

## 为什么需要消息队列？

消息队列的应用

- 异步处理
  - 快速响应
  - 减少等待，提升性能
- 流量控制
- 服务解耦

## 该如何选择消息队列？

- **是否开源**：这决定了能否商用，所以最为重要。
- **社区活跃度越高越好**：高社区活跃度，一般保证了低 Bug 率，因为大部分 Bug，已经有人遇到并解决了。
- **技术生态适配性**：客户端对各种编程语言的支持。比如：如果使用 MQ 的都是 Java 应用，那么 ActiveMQ、RabbitMQ、RocketMQ、Kafka 都可以。如果需要支持其他语言，那么 RMQ 比较合适，因为它支持的编程语言比较丰富。如果 MQ 是应用于大数据或流式计算，那么 Kafka 几乎是标配。如果是应用于在线业务系统，那么 Kafka 就不合适了，可以考虑 RabbitMQ、 RocketMQ 很合适。
- **高可用**：应用于线上的准入标准。
- **高性能**：具备足够好的性能，能满足绝大多数场景的性能要求。
- **业务场景的适应性**：不同业务场景，会有不同的诉求，此时要根据不同 MQ 的特性针对性选择。

### 主流 MQ

| 特性                     | ActiveMQ                   | RabbitMQ                                           | RocketMQ                                                                                                               | Kafka                                                                                                                                           |
| ------------------------ | -------------------------- | -------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 单机吞吐量               | 万级                       | 万级                                               | 十万级                                                                                                                 | 十万级，略高于 RocketMQ                                                                                                                         |
| topic 数量对吞吐量的影响 |                            |                                                    | topic 可以达到几百、几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic | topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 |
| 时效性                   | 毫秒级                     | 微秒级                                             | 毫秒级                                                                                                                 | 毫秒级以内                                                                                                                                      |
| 可用性                   | 高：基于主从架构实现高可用 | 同 ActiveMQ                                        | 非常高：分布式架构                                                                                                     | 非常高：分布式架构。每个数据都有多个副本，少数机器宕机，不会丢失数据，不会导致不可用                                                            |
| 消息可靠性               | 有较低的概率丢失数据       | 基本不丢                                           | 经过参数优化配置，可以做到不丢失                                                                                       | 同 RocketMQ                                                                                                                                     |
| 应用场景                 | MQ 领域的功能极其完备      | 基于 erlang 开发，并发能力很强，性能极好，延时很低 | 适合在线业务                                                                                                           | 大数据、实时计算以及日志采集领域，应用最为广泛                                                                                                  |
| 流行度                   | 不活跃                     | 社区非常活跃                                       | 阿里出品，有非常活跃的中文社区                                                                                         | 社区非常活跃                                                                                                                                    |
| 支持编程语言             |                            | 非常多                                             | Java                                                                                                                   | Scala、Java                                                                                                                                     |
| 学习成本                 |                            | 采用 ErLang 开发，比较小众，不利于扩展和二次开发   | 采用 Java 开发，且贡献者多为中国人，容易读懂源码                                                                       | 使用 Scala 和 Java 开发，容易读懂源码                                                                                                           |

RabbitMQ

突出亮点

1. 支持的编程语言最多
2. 支持非常灵活的路由配置

明显短板

1. 对消息堆积的支持并不好
2. 性能差强人意

# 消息模型：主题和队列有什么区别？

### 队列模型

最初的消息队列，就是一个严格意义上的队列。在计算机领域，“队列（Queue）”是一种数据结构，有完整而严格的定义。

**早期的消息队列，就是按照“队列”的数据结构来设计的。**生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。

如果有多个生产者往同一个队列里面发送消息，这个队列中可以消费到的消息，就是这些生产者生产的所有消息的合集。消息的顺序就是这些生产者发送消息的自然顺序。如果有多个消费者接收同一个队列的消息，这些消费者之间实际上是竞争的关系，每个消费者只能收到队列中的一部分消息，也就是说任何一条消息只能被其中的一个消费者收到。

如果需要将一份消息数据分发给多个消费者，要求每个消费者都能收到全量的消息。此时，单个队列就满足不了需求，一个可行的解决方式是，为每个消费者创建一个单独的队列，让生产者发送多份。显然这是个比较蠢的做法，同样的一份消息数据被复制到多个队列中会浪费资源，更重要的是，生产者必须知道有多少个消费者。为每个消费者单独发送一份消息，这实际上违背了消息队列“解耦”这个设计初衷。

### 发布 - 订阅模型（Publish-Subscribe Pattern）

在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。

队列模型和发布 - 订阅模型最大的区别就是：**一份消息数据能不能被消费多次的问题**。

### RabbitMQ 的消息模型

RabbitMQ，它是少数依然坚持使用队列模型的产品之一。那它是怎么解决多个消费者的问题呢？

在 RabbitMQ 中，Exchange 位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是将消息发送给 Exchange，由 Exchange 上配置的策略来决定将消息投递到哪些队列中。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220511211021.jfif)

同一份消息如果需要被多个消费者来消费，需要配置 Exchange 将消息发送到多个队列，每个队列中都存放一份完整的消息数据，可以为一个消费者提供消费服务。这也可以变相地实现新发布 - 订阅模型中，“一份消息数据可以被多个订阅者来多次消费”这样的功能。

### RocketMQ 的消息模型

RocketMQ 使用的消息模型是标准的发布 - 订阅模型

但是，在 RocketMQ 也有队列（Queue）这个概念，并且队列在 RocketMQ 中是一个非常重要的概念

几乎所有的消息队列产品都使用一种非常朴素的“请求 - 确认”机制，确保消息不会在传递过程中由于网络或服务器故障丢失。具体的做法也非常简单。在生产端，生产者先将消息发送给服务端，也就是 Broker，服务端在收到消息并将消息写入主题或者队列中后，会给生产者发送确认的响应。

如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息；在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。

这个确认机制很好地保证了消息传递过程中的可靠性，但是，引入这个机制在消费端带来了一个不小的问题。什么问题呢？为了确保消息的有序性，在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现消息空洞，违背了有序性这个原则。

也就是说，每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ 在主题下面增加了队列的概念。

**每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。**需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。

RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。

消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。

在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ 为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。这个消费位置是非常重要的概念，我们在使用消息队列的时候，丢消息的原因大多是由于消费位置处理不当导致的。
