---
title: 《SQL 必知必会》笔记
date: 2022-07-16 10:46:05
categories:
  - 笔记
  - 数据库
tags:
  - 架构
  - 数据库
permalink: /pages/34699b/
---

# 《SQL 必知必会》笔记

## SQL 语法基础

### SQL 语言划分

SQL 语言按照功能划分成以下的 4 个部分：

- **DDL**，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。
- **DML**，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。
- **DCL**，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。
- **DQL**，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道，因此学会编写正确且高效的查询语句，是学习的重点。

### DB、DBS 和 DBMS 的区别

DB、DBS 和 DBMS 的区别：

- DBMS 的英文全称是 DataBase Management System，数据库管理系统，实际上它可以对多个数据库进行管理，所以你可以理解为 DBMS = 多个数据库（DB） + 管理程序。
- DB 的英文是 DataBase，也就是数据库。数据库是存储数据的集合，你可以把它理解为多个数据表。
- DBS 的英文是 DataBase System，数据库系统。它是更大的概念，包括了数据库、数据库管理系统以及数据库管理人员 DBA。

NoSql 不同时期的释义

- 1970：NoSQL = We have no SQL
- 1980：NoSQL = Know SQL
- 2000：NoSQL = No SQL!
- 2005：NoSQL = Not only SQL
- 2013：NoSQL = No, SQL!

### Oracle 中的 SQL 是如何执行的

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220716105947.png)

1. **语法检查**：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。
2. **语义检查**：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。
3. **权限检查**：看用户是否具备访问该数据的权限。
4. **共享池检查**：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？
   - 在共享池中，Oracle 首先对 SQL 语句进行 Hash 运算，然后根据 Hash 值在库缓存（Library Cache）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是**软解析**。
   - 如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是**硬解析**。
5. **优化器**：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。
6. **执行器**：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。

共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。它主要缓存 SQL 语句和执行计划。

而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。

### MySQL 中的 SQL 是如何执行的

MySQL 是典型的 C/S 架构，即 Client/Server 架构，服务器端程序使用的 mysqld。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220716110905.png)

Mysql 可分为三层：

1. **连接层**：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；
2. **SQL 层**：对 SQL 语句进行查询处理；
3. **存储引擎层**：与数据库文件打交道，负责数据的存储和读取。

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220716111103.png)

SQL 层的结构

1. **查询缓存**：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。
2. **解析器**：在解析器中对 SQL 语句进行语法分析、语义分析。
3. **优化器**：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等。
4. **执行器**：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。

与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：

1. InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。
2. MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。
3. Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。
4. NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。
5. Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。

### 检索数据

SELECT 的作用是从一个表或多个表中检索出想要的数据行。

> - `SELECT` 语句用于从数据库中查询数据。
> - `DISTINCT` 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。
> - `LIMIT` 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。
>   - `ASC` ：升序（默认）
>   - `DESC` ：降序

查询单列

```sql
SELECT name FROM world.country;
```

查询多列

```sql
SELECT name, continent, region FROM world.country;
```

查询所有列

```sql
SELECT * FROM world.country;
```

查询不同的值

```sql
SELECT distinct(continent) FROM world.country;
```

限制查询结果

```sql
-- 返回前 5 行
SELECT * FROM world.country LIMIT 5;
SELECT * FROM world.country LIMIT 0, 5;
-- 返回第 3 ~ 5 行
SELECT * FROM world.country LIMIT 2, 3;
```

## SQL 性能优化

### 性能优化维度

我个人理解的性能优化维度与文章有所不同：

- 选择适合的数据库
- 配置优化
- 硬件优化
- 优化表设计
- 优化查询
- 使用缓存
- 读写分离+分库分表

### 范式设计

范式定义：

- **1NF**：指的是数据库表中的任何属性都是原子性的，不可再分。
- **2NF**：指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系。
- **3NF**：在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键。
- **BCNF**：在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。

**范式化的目标是尽力减少冗余列，节省空间**。

**反范式化的目标是适当增加冗余列，以避免关联查询**。
范式化优点

- 更节省空间
- 更新操作更快
- 更少需要 `DISTINCT` 或 `GROUP BY` 语句

范式化缺点

- 增加了关联查询，而关联查询代价很高

### 索引的适用场景

我认为，文章对于索引的适用场景讲解的不好。应该先讲清楚索引的优点和缺点，再结合其特性，来阐述适用场景。

#### 索引的优缺点

**索引的优点**

- 大大减少了服务器需要扫描的数据量
- 可以帮助服务器避免排序和临时表
- 可以将随机 I/O 变为顺序 I/O

**索引的缺点**

- 创建和维护索引要耗费时间，这会随着数据量的增加而增加。
- 占用额外物理空间
- 写操作时很可能需要更新索引，导致数据库的写操作性能降低

#### 索引的适用场景

**适用场景**

- 频繁读操作（SELECT）
- 表的数据量比较大
- 列名经常出现在 WHERE 或连接（JOIN）条件中

**不适用场景**

- 频繁写操作（INSERT/UPDATE/DELETE）
- 列名不经常出现在 WHERE 或连接（JOIN）条件中
- 索引会经常无法命中，没有意义
- 非常小的表（比如不到 1000 行）：简单的全表扫描更高效
- 特大型的表：索引的代价很高昂，可以用分区或 Nosql

### 索引使用什么数据结构

索引常见的数据结构

（1）哈希

只能用于等值查询。

Mysql 中，只有 Memory 存储引擎显示支持哈希索引。

哈希结构的缺点

- 哈希索引数据不是按照索引值顺序存储的——无法用于排序
- 哈希索引使用索引列的全部内容来进行哈希计算的——不支持联合索引的最左侧原则（即联合索引的部分索引）
- 只支持等值比较查询
  - 不支持范围查询
  - 不支持模糊查询
- 可能出现哈希冲突
  - 出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行
  - 如果哈希冲突多的话，维护索引的代价会很高

（2）B 树

非叶子节点包含索引和数据。

（3）空间数据索引（R 树）

（4）全文索引

## 认识 DBMS

## SQL 项目实战

# 参考资料

- [极客时间 - SQL 必知必会](https://time.geekbang.org/column/intro/192)
