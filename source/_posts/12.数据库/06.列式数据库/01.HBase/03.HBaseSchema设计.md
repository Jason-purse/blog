---
title: HBase Schema 设计
date: 2023-03-15 20:28:32
categories:
  - 数据库
  - 列式数据库
  - HBase
tags:
  - 大数据
  - HBase
permalink: /pages/a69528/
---

# HBase Schema 设计

Hbase 设计时要考虑的因素

- 这个表应该有多少 Column Family
- Column Family 使用什么数据
- 每个 Column Family 有有多少列
- 列名是什么，尽管列名不必在建表时定义，但读写数据是要知道的
- 单元应该存放什么数据
- 每个单元存储多少时间版本
- 行健(rowKey)结构是什么，应该包含什么信息

## HBase Schema 设计规则

### Column Family 设计

HBase 不能很好处理 2 ~ 3 个以上的 Column Family，所以 **HBase 表应尽可能减少 Column Family 数**。如果可以，请只使用一个列族，只有需要经常执行 Column 范围查询时，才引入多列族。也就是说，尽量避免同时查询多个列族。

- **Column Family 数量多，会影响数据刷新**。HBase 的数据刷新是在每个 Region 的基础上完成的。因此，如果一个 Column Family 携带大量导致刷新的数据，那么相邻的列族即使携带的数据量很小，也会被刷新。当存在许多 Column Family 时，刷新交互会导致一堆不必要的 IO。 此外，在表/区域级别的压缩操作也会在每个存储中发生。
- **Column Family 数量多，会影响查找效率**。如：Column Family A 有 100 万行，Column Family B 有 10 亿行，那么 Column Family A 的数据可能会分布在很多很多区域（和 RegionServers）。 这会降低 Column Family A 的批量扫描效率。

Column Family 名尽量简短，最好是一个字符。Column Family 会在列限定符中被频繁使用，缩短长度有利于节省空间并提升效率。

### Row 设计

**HBase 中的 Row 按 Row Key 的字典顺序排序**。

- **不要将 Row Key 设计为单调递增的**，例如：递增的整数或时间戳

  - 问题：因为 Hbase 的 Row Key 是就近存储的，这样会导致一段时间内大部分写入集中在某一个 Region 上，即所谓热点问题。

  - 解决方法一、加盐：这里的不是指密码学的加盐，而是指将随机分配的前缀添加到行键的开头。这么做是为了避免相同前缀的 Row Key 数据被存储在相邻位置，从而导致热点问题。示例如下：

    - ```
      foo0001
      foo0002
      foo0003
      foo0004

      改为

      a-foo0003
      b-foo0001
      c-foo0003
      c-foo0004
      d-foo0002
      ```

  - 解决方法二、Hash：Row Key 的前缀使用 Hash

- **尽量减少行和列的长度**

- **反向时间戳**：反向时间戳可以极大地帮助快速找到值的最新版本。

- **行健不能改变**：唯一可以改变的方式是先删除后插入。

- **Row Key 和 Column Family**：Row Key 从属于 Column Family，因此，相同的 Row Key 可以存在每一个 Column Family 中而不会出现冲突。

### Version 设计

最大、最小 Row 版本号：表示 HBase 会保留的版本号数的上下限。均可以通过 HColumnDescriptor 对每个列族进行配置

Row 版本号过大，会大大增加 StoreFile 的大小；所以，最大 Row 版本号应按需设置。HBase 会在主要压缩时，删除多余的版本。

### TTL 设计

Column Family 会设置一个以秒为单位的 TTL，一旦达到 TTL 时，HBase 会自动删除行记录。

仅包含过期行的存储文件在次要压缩时被删除。 将 hbase.store.delete.expired.storefile 设置为 false 会禁用此功能。将最小版本数设置为 0 以外的值也会禁用此功能。

在较新版本的 HBase 上，还支持在 Cell 上设置 TTL，与 Column Family 的 TTL 不同的是，单位是毫秒。

### Column Family 属性配置

- HFile 数据块，默认是 64KB，数据库的大小影响数据块索引的大小。数据块大的话一次加载进内存的数据越多，扫描查询效果越好。但是数据块小的话，随机查询性能更好

```
> create 'mytable',{NAME => 'cf1', BLOCKSIZE => '65536'}
复制代码
```

- 数据块缓存，数据块缓存默认是打开的，如果一些比较少访问的数据可以选择关闭缓存

```
> create 'mytable',{NAME => 'cf1', BLOCKCACHE => 'FALSE'}
复制代码
```

- 数据压缩，压缩会提高磁盘利用率，但是会增加 CPU 的负载，看情况进行控制

```
> create 'mytable',{NAME => 'cf1', COMPRESSION => 'SNAPPY'}
复制代码
```

Hbase 表设计是和需求相关的，但是遵守表设计的一些硬性指标对性能的提升还是很有帮助的，这里整理了一些设计时用到的要点。

## Schema 设计案例

### 案例：日志数据和时序数据

假设采集以下数据

- Hostname
- Timestamp
- Log event
- Value/message

应该如何设计 Row Key？

（1）Timestamp 在 Row Key 头部

如果 Row Key 设计为 `[timestamp][hostname][log-event]` 形式，会出现热点问题。

如果针对时间的扫描很重要，可以采用时间戳分桶策略，即

```
bucket = timestamp % bucketNum
```

计算出桶号后，将 Row Key 指定为：`[bucket][timestamp][hostname][log-event]`

如上所述，要为特定时间范围选择数据，需要对每个桶执行扫描。 例如，100 个桶将在键空间中提供广泛的分布，但需要 100 次扫描才能获取单个时间戳的数据，因此需要权衡取舍。

（2）Hostname 在 Row Key 头部

如果主机样本量很大，将 Row Key 设计为 `[hostname][log-event][timestamp]`，这样有利于扫描 hostname。

（3）Timestamp 还是反向 Timestamp

如果数据访问以查找最近的数据为主，可以将时间戳存储为反向时间戳（例如： `timestamp = Long.MAX_VALUE – timestamp`），这样有利于扫描最近的数据。

（4）Row Key 是可变长度还是固定长度

拼接 Row Key 的关键字长度不一定是固定的，例如 hostname 有可能很长，也有可能很短。如果想要统一长度，可以参考以下做法：

- 将关键字 Hash 编码：使用某种 Hash 算法计算关键字，并取固定长度的值（例如：8 位或 16 位）。
- 使用数字替代关键字：例如：使用事件类型 Code 替换事件类型；hostname 如果是 IP，可以转换为 long
- 截取关键字：截取后的关键字需要有足够的辨识度，长度大小根据具体情况权衡。

（5）时间分片

```
[hostname][log-event][timestamp1]
[hostname][log-event][timestamp2]
[hostname][log-event][timestamp3]
```

上面的例子中，每个详细事件都有单独的行键，可以重写如下，即每个时间段存储一次：

```
[hostname][log-event][timerange]
```

## 参考资料

- [HBase 官方文档之 HBase and Schema Design](https://hbase.apache.org/book.html#schema)